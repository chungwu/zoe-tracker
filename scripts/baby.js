// Generated by CoffeeScript 1.3.1
(function() {
  var FEED_ACTIONS, containsAction, containsActions, customBoundaryCond, dateBoundaryCond, deserializeEventRows, deserializeKeyRows, generateStateEvents, generateSummaries, getEventsDateRange, groupEventsByBoundary, handleData, intervalOverlap, renderEvents, renderGroupHeader, renderSummaries, renderTimelines, rowsToEvents, setGroupDateRanges, setRange, timeIn;

  handleData = function(data, tabletop) {
    var $alignControls, alignKeys, allEvents, curTimelines, eventKeys, eventTrendKeys, events, flags, k, key, keys, rows, stateEvents, stateKeys, stateTrendKeys, _i, _len, _ref, _ref1;
    console.log("Data loaded!");
    $(".loader").hide();
    $(".main-content").show();
    window.data = data;
    window.tabletop = tabletop;
    keys = deserializeKeyRows(data);
    flags = _.object((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        k = keys[_i];
        if (k.type === "flag") {
          _results.push([k.name, k.value]);
        }
      }
      return _results;
    })());
    document.title = (_ref = flags["title"]) != null ? _ref : "Trackinator";
    $("h1").text((_ref1 = flags["title"]) != null ? _ref1 : "Trackinator");
    eventKeys = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        k = keys[_i];
        if (k.type === "event") {
          _results.push(k);
        }
      }
      return _results;
    })();
    stateKeys = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        k = keys[_i];
        if (k.type === "state") {
          _results.push(k);
        }
      }
      return _results;
    })();
    eventTrendKeys = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        k = keys[_i];
        if (k.type === "event-trend") {
          _results.push(k);
        }
      }
      return _results;
    })();
    stateTrendKeys = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        k = keys[_i];
        if (k.type === "state-trend") {
          _results.push(k);
        }
      }
      return _results;
    })();
    alignKeys = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        k = keys[_i];
        if (k.type === "align") {
          _results.push(k);
        }
      }
      return _results;
    })();
    rows = deserializeEventRows(data);
    events = rowsToEvents(rows, eventKeys);
    stateEvents = generateStateEvents(events, stateKeys);
    allEvents = _.sortBy(events.concat(stateEvents), function(ev) {
      return ev.start;
    });
    curTimelines = [[]];
    if (alignKeys.length === 0) {
      $(".alignment-controls").hide();
    } else {
      $alignControls = $(".alignment-controls .controls-options").empty();
      $("<label><input type='radio' name='align' value='date' checked/>Date</label>").appendTo($alignControls);
      for (_i = 0, _len = alignKeys.length; _i < _len; _i++) {
        key = alignKeys[_i];
        $("<label/>").text(key.name).prepend($("<input type='radio' name='align'/>").prop("value", key.name)).appendTo($alignControls);
      }
    }
    $(".alignment-controls input").click(function() {
      return curTimelines[0] = renderTimelines(allEvents, $(this).prop("value"), alignKeys, eventTrendKeys, stateTrendKeys);
    });
    $(".expansion-controls input").click(function() {
      var timeline, timelines, _j, _k, _len1, _len2, _ref2, _ref3, _results, _results1;
      timelines = curTimelines[0];
      if ($(this).is(":checked")) {
        _ref2 = timelines.slice(0, timelines.length - 1);
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          timeline = _ref2[_j];
          timeline.setGroups([
            {
              id: "point",
              content: "Events"
            }
          ]);
          _results.push(timeline.setOptions({
            height: "200px",
            stack: true
          }));
        }
        return _results;
      } else {
        _ref3 = timelines.slice(0, timelines.length - 1);
        _results1 = [];
        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
          timeline = _ref3[_k];
          timeline.setGroups([
            {
              id: "state",
              content: "State"
            }
          ]);
          _results1.push(timeline.setOptions({
            height: null,
            stack: false
          }));
        }
        return _results1;
      }
    });
    return curTimelines[0] = renderTimelines(allEvents, "date", alignKeys, eventTrendKeys, stateTrendKeys);
  };

  renderGroupHeader = function(group, stateTrendKeys, eventTrendKeys) {
    var $aggs, $container, event, eventStats, k, key, stateStats, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    $container = $("<div/>");
    $container.append($("<h2/>").text(group.title));
    $aggs = $("<ul/>").addClass("aggs").appendTo($container);
    stateStats = _.object((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = stateTrendKeys.length; _i < _len; _i++) {
        k = stateTrendKeys[_i];
        _results.push([k.name, 0]);
      }
      return _results;
    })());
    eventStats = _.object((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = eventTrendKeys.length; _i < _len; _i++) {
        k = eventTrendKeys[_i];
        _results.push([k.name, 0]);
      }
      return _results;
    })());
    _ref = group.events;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      event = _ref[_i];
      if (event.stateKey != null) {
        for (_j = 0, _len1 = stateTrendKeys.length; _j < _len1; _j++) {
          key = stateTrendKeys[_j];
          if (containsAction(event.stateKey.name, key.value)) {
            stateStats[key.name] += intervalOverlap(event.start, event.end, group.minDate, group.maxDate);
          }
        }
      } else {
        for (_k = 0, _len2 = eventTrendKeys.length; _k < _len2; _k++) {
          key = eventTrendKeys[_k];
          if (containsActions([(_ref1 = event.eventKey) != null ? _ref1.name : void 0, event.text], key.value)) {
            eventStats[key.name] += 1;
          }
        }
      }
    }
    for (_l = 0, _len3 = stateTrendKeys.length; _l < _len3; _l++) {
      key = stateTrendKeys[_l];
      $("<li/>").append($("<span class='agg-key'/>").text("" + key.name).css("backgroundColor", (_ref3 = key.backgroundcolor) != null ? _ref3 : "").css("color", (_ref2 = key.foregroundcolor) != null ? _ref2 : "")).append($("<span class='agg-val'/>").text("" + (moment.duration(stateStats[key.name]).humanize()))).appendTo($aggs);
    }
    for (_m = 0, _len4 = eventTrendKeys.length; _m < _len4; _m++) {
      key = eventTrendKeys[_m];
      $("<li/>").append($("<span class='agg-key'/>").text("" + key.name).css("backgroundColor", (_ref5 = key.backgroundcolor) != null ? _ref5 : "").css("color", (_ref4 = key.foregroundcolor) != null ? _ref4 : "")).append($("<span class='agg-val'/>").text("" + eventStats[key.name] + "x")).appendTo($aggs);
    }
    return $container;
  };

  renderTimelines = function(allEvents, mode, alignKeys, eventTrendKeys, stateTrendKeys) {
    var $body, $summariesTimeline, $table, $timeline, $tr, boundaryCond, group, groupedEvents, handlingEvent, summariesTimeline, timeline, timelines, _i, _j, _len, _len1, _ref;
    boundaryCond = mode === "date" ? dateBoundaryCond : customBoundaryCond((_.find(alignKeys, function(k) {
      return k.name === mode;
    })).value);
    groupedEvents = groupEventsByBoundary(allEvents, boundaryCond);
    setGroupDateRanges(mode, groupedEvents);
    $body = $(".timelines-container").empty();
    $table = $("<table/>").addClass("timelines-table").appendTo($body);
    $tr = $("<tr/>").appendTo($table);
    $("<td/>").addClass("header").appendTo($tr).append($("<h2/>").text("Trends"));
    $summariesTimeline = $("<td/>").appendTo($tr);
    timelines = [];
    _ref = groupedEvents.reverse();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      $tr = $("<tr/>").appendTo($table);
      $("<td/>").addClass("header").appendTo($tr).append(renderGroupHeader(group, stateTrendKeys, eventTrendKeys));
      $timeline = $("<td/>").appendTo($tr);
      timeline = renderEvents($timeline, group);
      timelines.push(timeline);
    }
    summariesTimeline = generateSummaries($summariesTimeline, timelines, eventTrendKeys, stateTrendKeys);
    timelines.push(summariesTimeline);
    window.st = summariesTimeline;
    window.timelines = timelines;
    handlingEvent = false;
    for (_j = 0, _len1 = timelines.length; _j < _len1; _j++) {
      timeline = timelines[_j];
      timeline.on("rangechanged", function(event) {
        if (handlingEvent) {
          return;
        }
        handlingEvent = true;
        setRange(timelines, event.start, event.end);
        return handlingEvent = false;
      });
    }
    setRange(timelines, timelines[0].getWindow().start, timelines[0].getWindow().end);
    return timelines;
  };

  setGroupDateRanges = function(mode, groups) {
    var g, group, i, maxDuration, range, _i, _j, _k, _len, _len1, _len2, _results, _results1;
    for (_i = 0, _len = groups.length; _i < _len; _i++) {
      g = groups[_i];
      range = getEventsDateRange(g.events);
      g.firstDate = range.min;
      g.lastDate = range.max;
    }
    if (mode === "date") {
      _results = [];
      for (i = _j = 0, _len1 = groups.length; _j < _len1; i = ++_j) {
        group = groups[i];
        group.minDate = moment(group.firstDate).startOf("day").toDate();
        _results.push(group.maxDate = moment(group.lastDate).endOf("day").toDate());
      }
      return _results;
    } else {
      maxDuration = _.max((function() {
        var _k, _len2, _results1;
        _results1 = [];
        for (_k = 0, _len2 = groups.length; _k < _len2; _k++) {
          g = groups[_k];
          _results1.push(g.lastDate - g.firstDate);
        }
        return _results1;
      })());
      _results1 = [];
      for (_k = 0, _len2 = groups.length; _k < _len2; _k++) {
        group = groups[_k];
        group.minDate = moment(group.firstDate).toDate();
        _results1.push(group.maxDate = moment(group.firstDate).add(maxDuration, "milliseconds").toDate());
      }
      return _results1;
    }
  };

  setRange = function(timelines, start, end) {
    var anchor, rangeDiff, startDiff, tend, timeline, tstart, _i, _len, _results;
    anchor = _.find(timelines, function(t) {
      return t.getWindow().start.valueOf() === start.valueOf() && t.getWindow().end.valueOf() === end.valueOf();
    });
    startDiff = start - anchor.dateRange.min;
    rangeDiff = end - start;
    _results = [];
    for (_i = 0, _len = timelines.length; _i < _len; _i++) {
      timeline = timelines[_i];
      if (timeline === anchor) {
        continue;
      } else {
        tstart = moment(timeline.dateRange.min).add(startDiff, "ms");
        tend = moment(tstart + rangeDiff);
        _results.push(timeline.setWindow(tstart.toDate(), tend.toDate(), {
          animate: false
        }));
      }
    }
    return _results;
  };

  FEED_ACTIONS = ["feed", "nurse"];

  containsAction = function(action, checks) {
    var s;
    return _.any((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = checks.length; _i < _len; _i++) {
        s = checks[_i];
        _results.push(action.toLowerCase().indexOf(s) >= 0);
      }
      return _results;
    })());
  };

  dateBoundaryCond = function(cur, event) {
    var day;
    day = moment(event.start).format("MMMM Do");
    if (cur !== day) {
      return day;
    } else {
      return;
    }
  };

  customBoundaryCond = function(values) {
    return function(cur, event) {
      if (containsAction(event.text, values)) {
        return moment(event.start).format("MMMM Do, h:ma");
      } else {

      }
    };
  };

  groupEventsByBoundary = function(events, boundaryCondition) {
    var boundary, curBoundary, curEvents, curState, event, results, _i, _len;
    results = [];
    curBoundary = void 0;
    curEvents = [];
    curState = void 0;
    for (_i = 0, _len = events.length; _i < _len; _i++) {
      event = events[_i];
      boundary = boundaryCondition(curBoundary, event);
      if (boundary != null) {
        if (curEvents.length > 0) {
          results.push({
            title: curBoundary,
            events: curEvents
          });
          curEvents = [];
          if (curState != null) {
            curEvents.push(curState);
          }
        }
        curBoundary = boundary;
      }
      if (!(curBoundary != null)) {
        continue;
      }
      curEvents.push(event);
      if (event.end != null) {
        curState = event;
      }
    }
    if (curEvents.length > 0) {
      results.push({
        title: curBoundary,
        events: curEvents
      });
    }
    return results;
  };

  rowsToEvents = function(rows, eventKeys) {
    return _.map(rows, function(row) {
      var eventKey, _ref, _ref1, _ref2;
      eventKey = _.find(eventKeys, function(k) {
        return containsAction(row.action, k.value);
      });
      return {
        content: $("<span/>").append($("<span class='event-content'/>").append($("<span class='event-time event-start'/>").text(row.timestamp.format("h:mm:ssa"))).append($("<span class='event-action'/>").text(row.action))).html(),
        text: row.action,
        start: row.timestamp.toDate(),
        group: "point",
        type: "box",
        title: row.action,
        eventKey: eventKey,
        style: "background-color: " + ((_ref = eventKey != null ? eventKey.backgroundcolor : void 0) != null ? _ref : '') + "; border-color: " + ((_ref1 = eventKey != null ? eventKey.backgroundcolor : void 0) != null ? _ref1 : '') + "; color: " + ((_ref2 = eventKey != null ? eventKey.foregroundcolor : void 0) != null ? _ref2 : '') + ";"
      };
    });
  };

  containsActions = function(actions, values) {
    var action, _i, _len;
    for (_i = 0, _len = actions.length; _i < _len; _i++) {
      action = actions[_i];
      if ((action != null) && containsAction(action, values)) {
        return true;
      }
    }
    return false;
  };

  generateStateEvents = function(events, stateKeys) {
    var curState, event, results, stateContentHtml, stateKey, _i, _len, _ref, _ref1, _ref2;
    results = [];
    curState = void 0;
    stateContentHtml = function(state) {
      return $("<div/>").append($("<div class='event-content'/>").append($("<div class='event-time event-start'/>").text(moment(state.start).format("h:mm:ssa"))).append($("<div class='event-action'/>").text(state.text)).append($("<div class='event-time event-end'/>").text(moment(state.end).format("h:mm:ssa")))).html();
    };
    for (_i = 0, _len = events.length; _i < _len; _i++) {
      event = events[_i];
      stateKey = _.find(stateKeys, function(k) {
        var _ref;
        return containsActions([event.text, (_ref = event.eventKey) != null ? _ref.name : void 0], k.value);
      });
      if (stateKey != null) {
        if ((curState != null) && curState.text !== stateKey.name) {
          curState.end = event.start;
          curState.content = stateContentHtml(curState);
          results.push(curState);
        }
        if (!(curState != null) || (curState != null ? curState.text : void 0) !== stateKey.name) {
          curState = {
            content: "",
            text: stateKey.name,
            start: event.start,
            group: "state",
            type: "range",
            title: stateKey.name,
            stateKey: stateKey,
            style: "background-color: " + ((_ref = stateKey.backgroundcolor) != null ? _ref : '') + "; border-color: " + ((_ref1 = stateKey.backgroundcolor) != null ? _ref1 : '') + "; color: " + ((_ref2 = stateKey.foregroundcolor) != null ? _ref2 : '') + ";"
          };
        }
      }
    }
    if (curState != null) {
      curState.end = moment(curState.start).add(1, "hour").toDate();
      curState.content = stateContentHtml(curState);
      results.push(curState);
    }
    return results;
  };

  getEventsDateRange = function(events) {
    var ev, maxEvent, minEvent, pointEvents;
    pointEvents = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = events.length; _i < _len; _i++) {
        ev = events[_i];
        if (!(ev.end != null)) {
          _results.push(ev);
        }
      }
      return _results;
    })();
    maxEvent = _.max(pointEvents, function(ev) {
      return ev.start;
    });
    minEvent = _.min(pointEvents, function(ev) {
      return ev.start;
    });
    return {
      min: minEvent.start,
      max: maxEvent.start
    };
  };

  renderSummaries = function($container, title, events) {
    var $timeline, items;
    $("<h2/>").text(title).appendTo($container);
    $timeline = $("<div/>").appendTo($container);
    return items = new vis.DataSet();
  };

  generateSummaries = function($container, timelines, eventTrendKeys, stateTrendKeys) {
    var PERIOD, aggregateInterval, dateRange, duration, end, endTime, events, groups, i, intervals, iv, j, k, key, maxEventKeys, maxStateKeys, minEventKeys, minStateKeys, now, options, start, startTime, t, timeline, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    PERIOD = 30;
    duration = _.max((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = timelines.length; _i < _len; _i++) {
        t = timelines[_i];
        _results.push(t.dateRange.max - t.dateRange.min);
      }
      return _results;
    })());
    intervals = [];
    for (i = _i = 0, _ref = Math.ceil(duration / (PERIOD * 60 * 1000)); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      iv = {
        index: i
      };
      for (_j = 0, _len = eventTrendKeys.length; _j < _len; _j++) {
        key = eventTrendKeys[_j];
        iv[key.name] = 0;
      }
      for (_k = 0, _len1 = stateTrendKeys.length; _k < _len1; _k++) {
        key = stateTrendKeys[_k];
        iv[key.name] = 0;
      }
      intervals.push(iv);
    }
    aggregateInterval = function(timeline, interval, start, end) {
      var event, key, overlap, _l, _len2, _ref1, _results;
      _ref1 = timeline.itemsData.get();
      _results = [];
      for (_l = 0, _len2 = _ref1.length; _l < _len2; _l++) {
        event = _ref1[_l];
        if (stateTrendKeys.length > 0 && (event.stateKey != null) && event.group === "state") {
          overlap = intervalOverlap(event.start, event.end, start, end);
          if (overlap > 0) {
            _results.push((function() {
              var _len3, _m, _results1;
              _results1 = [];
              for (_m = 0, _len3 = stateTrendKeys.length; _m < _len3; _m++) {
                key = stateTrendKeys[_m];
                if (containsAction(event.stateKey.name, key.value)) {
                  _results1.push(interval[key.name] += overlap / 1000 / 60);
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
            })());
          } else {
            _results.push(void 0);
          }
        } else if (eventTrendKeys.length > 0 && event.group === "point" && timeIn(event.start, start, end)) {
          _results.push((function() {
            var _len3, _m, _ref2, _results1;
            _results1 = [];
            for (_m = 0, _len3 = eventTrendKeys.length; _m < _len3; _m++) {
              key = eventTrendKeys[_m];
              if (containsActions([(_ref2 = event.eventKey) != null ? _ref2.name : void 0, event.text], key.value)) {
                _results1.push(interval[key.name] += 1);
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          })());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    for (i = _l = 0, _len2 = intervals.length; _l < _len2; i = ++_l) {
      iv = intervals[i];
      for (_m = 0, _len3 = timelines.length; _m < _len3; _m++) {
        timeline = timelines[_m];
        start = moment(timeline.dateRange.min).add(i * PERIOD, "minutes").toDate();
        end = moment(start).add(PERIOD, "minutes").toDate();
        aggregateInterval(timeline, iv, start, end);
      }
    }
    now = moment();
    startTime = moment(now).startOf("day");
    events = [];
    maxStateKeys = (function() {
      var _len4, _n, _results;
      _results = [];
      for (_n = 0, _len4 = stateTrendKeys.length; _n < _len4; _n++) {
        k = stateTrendKeys[_n];
        _results.push(_.max((function() {
          var _len5, _o, _results1;
          _results1 = [];
          for (_o = 0, _len5 = intervals.length; _o < _len5; _o++) {
            iv = intervals[_o];
            _results1.push(iv[k.name]);
          }
          return _results1;
        })()));
      }
      return _results;
    })();
    minStateKeys = (function() {
      var _len4, _n, _results;
      _results = [];
      for (_n = 0, _len4 = stateTrendKeys.length; _n < _len4; _n++) {
        k = stateTrendKeys[_n];
        _results.push(_.min((function() {
          var _len5, _o, _results1;
          _results1 = [];
          for (_o = 0, _len5 = intervals.length; _o < _len5; _o++) {
            iv = intervals[_o];
            _results1.push(iv[k.name]);
          }
          return _results1;
        })()));
      }
      return _results;
    })();
    maxEventKeys = (function() {
      var _len4, _n, _results;
      _results = [];
      for (_n = 0, _len4 = eventTrendKeys.length; _n < _len4; _n++) {
        k = eventTrendKeys[_n];
        _results.push(_.max((function() {
          var _len5, _o, _results1;
          _results1 = [];
          for (_o = 0, _len5 = intervals.length; _o < _len5; _o++) {
            iv = intervals[_o];
            _results1.push(iv[k.name]);
          }
          return _results1;
        })()));
      }
      return _results;
    })();
    minEventKeys = (function() {
      var _len4, _n, _results;
      _results = [];
      for (_n = 0, _len4 = eventTrendKeys.length; _n < _len4; _n++) {
        k = eventTrendKeys[_n];
        _results.push(_.min((function() {
          var _len5, _o, _results1;
          _results1 = [];
          for (_o = 0, _len5 = intervals.length; _o < _len5; _o++) {
            iv = intervals[_o];
            _results1.push(iv[k.name]);
          }
          return _results1;
        })()));
      }
      return _results;
    })();
    for (i = _n = 0, _len4 = intervals.length; _n < _len4; i = ++_n) {
      iv = intervals[i];
      endTime = moment(startTime).add(PERIOD, "minutes");
      for (j = _o = 0, _len5 = stateTrendKeys.length; _o < _len5; j = ++_o) {
        key = stateTrendKeys[j];
        events.push({
          content: "" + iv[key.name],
          text: "" + iv[key.name],
          title: "" + iv[key.name],
          start: startTime.toDate(),
          end: endTime.toDate(),
          group: key.name,
          type: "background",
          className: "summary",
          style: "background-color: " + ((_ref1 = key.backgroundcolor) != null ? _ref1 : '') + "; border-color: " + ((_ref2 = key.backgroundcolor) != null ? _ref2 : '') + "; color: " + ((_ref3 = key.foregroundcolor) != null ? _ref3 : '') + "; opacity: " + ((iv[key.name] - minStateKeys[j]) / (maxStateKeys[j] - minStateKeys[j]))
        });
      }
      for (j = _p = 0, _len6 = eventTrendKeys.length; _p < _len6; j = ++_p) {
        key = eventTrendKeys[j];
        events.push({
          content: "" + iv[key.name],
          text: "" + iv[key.name],
          title: "" + iv[key.name],
          start: startTime.toDate(),
          end: endTime.toDate(),
          group: key.name,
          type: "background",
          className: "summary",
          style: "background-color: " + ((_ref4 = key.backgroundcolor) != null ? _ref4 : '') + "; border-color: " + ((_ref5 = key.backgroundcolor) != null ? _ref5 : '') + "; color: " + ((_ref6 = key.foregroundcolor) != null ? _ref6 : '') + "; opacity: " + ((iv[key.name] - minEventKeys[j]) / (maxEventKeys[j] - minEventKeys[j]))
        });
      }
      startTime = endTime;
    }
    dateRange = {
      min: moment(now).startOf("day").toDate(),
      max: moment(now).startOf("day").add(PERIOD * intervals.length, "minutes").toDate()
    };
    options = {
      showMajorLabels: false,
      min: moment(dateRange.min).subtract(1, "hour").toDate(),
      max: moment(dateRange.max).add(1, "hour").toDate()
    };
    groups = (function() {
      var _len7, _q, _ref7, _results;
      _ref7 = stateTrendKeys.concat(eventTrendKeys);
      _results = [];
      for (_q = 0, _len7 = _ref7.length; _q < _len7; _q++) {
        k = _ref7[_q];
        _results.push({
          id: k.name,
          content: k.name
        });
      }
      return _results;
    })();
    timeline = new vis.Timeline($container[0], events, groups, options);
    timeline.dateRange = dateRange;
    return timeline;
  };

  intervalOverlap = function(start1, end1, start2, end2) {
    if (start1 <= start2 && end1 >= end2) {
      return end2 - start2;
    } else if (start1 >= start2 && end1 <= end2) {
      return end1 - start1;
    } else if (start1 <= start2 && end1 >= start2) {
      return end1 - start2;
    } else if (start1 >= start2 && start1 <= end2) {
      return end2 - start1;
    } else {
      return 0;
    }
  };

  timeIn = function(date, start, end) {
    return date >= start && date <= end;
  };

  renderEvents = function($container, group) {
    var bgEvent, event, items, options, timeline, _i, _len, _ref;
    items = new vis.DataSet();
    options = {
      height: "200px",
      padding: 2,
      showMajorLabels: false,
      max: moment(group.maxDate).add(1, "hour").toDate(),
      min: moment(group.minDate).subtract(1, "hour").toDate()
    };
    _ref = group.events;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      event = _ref[_i];
      items.add(event);
      if (event.end != null) {
        bgEvent = _.clone(_.omit(event, ["id"]));
        _.extend(bgEvent, {
          group: "point",
          content: "",
          style: bgEvent.style + "; opacity: 0.2",
          type: "background"
        });
        items.add(bgEvent);
      }
    }
    timeline = new vis.Timeline($container[0], items, [
      {
        id: "point",
        content: "Events"
      }
    ], options);
    timeline.dateRange = {
      max: group.maxDate,
      min: group.minDate
    };
    return timeline;
  };

  deserializeKeyRows = function(data) {
    var key, keys, s, _i, _len, _ref, _ref1;
    keys = (_ref = (_ref1 = data["Keys"]) != null ? _ref1.all() : void 0) != null ? _ref : [];
    for (_i = 0, _len = keys.length; _i < _len; _i++) {
      key = keys[_i];
      key.value = (function() {
        var _j, _len1, _ref2, _results;
        _ref2 = key.value.split(",");
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          s = _ref2[_j];
          _results.push(s.trim());
        }
        return _results;
      })();
    }
    return keys;
  };

  deserializeEventRows = function(data) {
    var allRows, name, row, rows, sheet, sheetName, submitTimestamp, _i, _len;
    allRows = [];
    for (sheetName in data) {
      sheet = data[sheetName];
      rows = sheet.elements;
      if (_.all((function() {
        var _i, _len, _ref, _results;
        _ref = ["timestamp", "time", "action", "date", "minutesago"];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          name = _ref[_i];
          _results.push(_.contains(sheet.column_names, name));
        }
        return _results;
      })())) {
        for (_i = 0, _len = rows.length; _i < _len; _i++) {
          row = rows[_i];
          submitTimestamp = row.timestamp ? moment(row.timestamp, "M/DD/YYYY H:mm:ss") : void 0;
          if (row.minutesago) {
            row.timestamp = submitTimestamp.subtract(parseInt(row.minutesago), "minutes");
          } else if (!row.time) {
            row.timestamp = submitTimestamp;
          } else if (!row.date) {
            row.timestamp = moment("" + (submitTimestamp.format('M/DD/YYYY')) + " " + row.time, "M/DD/YYYY H:mm:ss A");
          } else {
            row.timestamp = moment("" + row.date + " " + row.time, "M/DD/YYYY H:mm:ss A");
          }
          allRows.push(row);
        }
      } else {
        console.log("Skipping sheet " + sheetName);
      }
    }
    return _.sortBy(allRows, function(r) {
      return r.timestamp.valueOf();
    });
  };

  $(function() {
    var hash, key;
    hash = window.location.hash.substring(1);
    if (hash) {
      key = hash;
    } else {
      key = SPREADSHEET_KEY;
    }
    if (!key) {
      key = prompt("What is the key for the spreadsheet?");
      window.location.hash = "#" + key;
      window.location.reload();
      return;
    }
    console.log("Loading data...");
    return Tabletop.init({
      key: key,
      callback: handleData
    });
  });

}).call(this);
